using System;
using System.Drawing;
using System.IO;
using System.Text;
using System.Windows.Forms;
using WeifenLuo.WinFormsUI.Docking;
using ScintillaNET;

namespace WinForms_Docable
{
    public class CodeEditorPanel : DockContent
    {
        public string FilePath { get; }
        private readonly ScintillaNET.Scintilla _editor;

        public CodeEditorPanel(string filePath)
        {
            FilePath = filePath;
            Text = Path.GetFileName(filePath);
            DockAreas = DockAreas.Document;

            try
            {
                _editor = new ScintillaNET.Scintilla
                {
                    Dock = DockStyle.Fill,
                    Font = new System.Drawing.Font("Consolas", 10f),
                };
            }
            catch (MissingMethodException)
            {
                // Fallback editor to avoid crash (no highlighting here)
                var rtb = new RichTextBox
                {
                    Dock = DockStyle.Fill,
                    Font = new System.Drawing.Font("Consolas", 10f),
                    ReadOnly = false,
                    Multiline = true
                };
                Controls.Add(rtb);
                rtb.Text = File.ReadAllText(filePath, Encoding.UTF8);
                return;
            }

            Controls.Add(_editor);

            // Configure highlighting first, then load text.
            ApplySyntaxHighlightingByExtension(Path.GetExtension(filePath));
            _editor.Text = File.ReadAllText(filePath, Encoding.UTF8);
        }

        private void ApplySyntaxHighlightingByExtension(string? ext)
        {
            // Treat .c (and optionally .h) as C; .cpp/.cxx/.cc as C++ if desired.
            if (string.Equals(ext, ".c", StringComparison.OrdinalIgnoreCase))
            {
                ConfigureCommonEditor();
                ConfigureCStyling();
            }
            else if (string.Equals(ext, ".h", StringComparison.OrdinalIgnoreCase))
            {
                // Many projects use C headers; you can switch this to C++ if needed.
                ConfigureCommonEditor();
                ConfigureCStyling();
            }
            else if (string.Equals(ext, ".cpp", StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(ext, ".cxx", StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(ext, ".cc", StringComparison.OrdinalIgnoreCase))
            {
                ConfigureCommonEditor();
                ConfigureCStyling(); // C/C++ share the same lexer (Cpp) in Scintilla
            }
            else if (string.Equals(ext, ".asm", StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(ext, ".s",   StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(ext, ".inc", StringComparison.OrdinalIgnoreCase)) // common asm include
            {
                ConfigureCommonEditor();
                ConfigureAsmStyling();
            }
            else if (string.Equals(Path.GetFileName(FilePath), "Makefile", StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(Path.GetFileName(FilePath), "GNUmakefile", StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(ext, ".mak", StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(ext, ".mk", StringComparison.OrdinalIgnoreCase))
            {
                ConfigureCommonEditor();
                ConfigureMakefileStyling();
            }
            else if (string.Equals(ext, ".ps1", StringComparison.OrdinalIgnoreCase))
            {
                ConfigureCommonEditor();
                ConfigurePowerShellStyling();
            }
            else
            {
                ConfigureCommonEditor(); // still set up line numbers, tabs, etc.
            }
        }

        private void ConfigureCommonEditor()
        {
            // Line numbers
            _editor.Margins[0].Type = MarginType.Number;
            _editor.Margins[0].Width = 36;

            // Code folding margin
            _editor.SetProperty("fold", "1");
            _editor.Margins[2].Type = MarginType.Symbol;
            _editor.Margins[2].Mask = Marker.MaskFolders;
            _editor.Margins[2].Sensitive = true;
            _editor.Margins[2].Width = 18;

            // Fold markers
            _editor.Markers[Marker.Folder].Symbol = MarkerSymbol.BoxPlus;
            _editor.Markers[Marker.FolderOpen].Symbol = MarkerSymbol.BoxMinus;
            _editor.Markers[Marker.FolderEnd].Symbol = MarkerSymbol.BoxPlusConnected;
            _editor.Markers[Marker.FolderMidTail].Symbol = MarkerSymbol.TCorner;
            _editor.Markers[Marker.FolderOpenMid].Symbol = MarkerSymbol.BoxMinusConnected;
            _editor.Markers[Marker.FolderSub].Symbol = MarkerSymbol.VLine;
            _editor.Markers[Marker.FolderTail].Symbol = MarkerSymbol.LCorner;

            // Tabs/indent
            _editor.TabWidth = 4;
            _editor.UseTabs = false;
            _editor.IndentationGuides = IndentView.LookBoth;

            // Caret/selection
            _editor.CaretLineVisible = true;
            _editor.CaretLineBackColor = Color.FromArgb(12, 125, 255, 255); // subtle
        }

        private void ConfigureCStyling()
        {
            // C/C++ share the same lexer
            _editor.Lexer = Lexer.Cpp;

            // Reset and set defaults
            _editor.StyleResetDefault();
            _editor.Styles[Style.Default].Font = "Consolas";
            _editor.Styles[Style.Default].Size = 10;
            _editor.Styles[Style.Default].BackColor = Color.White;
            _editor.Styles[Style.Default].ForeColor = Color.Black;
            _editor.StyleClearAll();

            // Styles
            _editor.Styles[Style.Cpp.Comment].ForeColor = Color.FromArgb(0, 128, 0);
            _editor.Styles[Style.Cpp.CommentLine].ForeColor = Color.FromArgb(0, 128, 0);
            _editor.Styles[Style.Cpp.CommentDoc].ForeColor = Color.FromArgb(0, 128, 0);
            _editor.Styles[Style.Cpp.Number].ForeColor = Color.FromArgb(128, 0, 128);
            _editor.Styles[Style.Cpp.String].ForeColor = Color.FromArgb(163, 21, 21);
            _editor.Styles[Style.Cpp.Character].ForeColor = Color.FromArgb(163, 21, 21);
            _editor.Styles[Style.Cpp.Preprocessor].ForeColor = Color.FromArgb(128, 0, 0);
            _editor.Styles[Style.Cpp.Operator].ForeColor = Color.FromArgb(0, 0, 0);
            _editor.Styles[Style.Cpp.Identifier].ForeColor = Color.Black;
            _editor.Styles[Style.Cpp.Word].ForeColor = Color.FromArgb(0, 0, 255); // keywords
            _editor.Styles[Style.Cpp.Word].Bold = true;
            _editor.Styles[Style.Cpp.Word2].ForeColor = Color.FromArgb(43, 145, 175); // types/classes

            // Set keywords (set 0 = keywords, 1 = types/secondary)
            _editor.SetKeywords(0,
                "auto break case char const continue default do double else enum extern "
              + "float for goto if inline int long register restrict return short signed sizeof "
              + "static struct switch typedef union unsigned void volatile while "
              + "_Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary _Noreturn "
              + "_Static_assert _Thread_local");

            _editor.SetKeywords(1,
                "size_t ptrdiff_t int8_t int16_t int32_t int64_t uint8_t uint16_t "
              + "uint32_t uint64_t wchar_t bool");

            // Operators are recognized by the lexer
            // _editor.SetCharsDefault(); // not available in ScintillaNET
        }

        private void ConfigureAsmStyling()
        {
            _editor.Lexer = Lexer.Asm;

            // Reset and set defaults
            _editor.StyleResetDefault();
            _editor.Styles[Style.Default].Font      = "Consolas";
            _editor.Styles[Style.Default].Size      = 10;
            _editor.Styles[Style.Default].BackColor = Color.White;
            _editor.Styles[Style.Default].ForeColor = Color.Black;
            _editor.StyleClearAll();

            // Common ASM styles (names may vary slightly by ScintillaNET version)
            _editor.Styles[Style.Asm.Comment].ForeColor     = Color.FromArgb(0, 128, 0);
            _editor.Styles[Style.Asm.Number].ForeColor      = Color.FromArgb(128, 0, 128);
            _editor.Styles[Style.Asm.String].ForeColor      = Color.FromArgb(163, 21, 21);
            _editor.Styles[Style.Asm.Character].ForeColor   = Color.FromArgb(163, 21, 21);
            _editor.Styles[Style.Asm.Operator].ForeColor    = Color.Black;
            _editor.Styles[Style.Asm.Identifier].ForeColor  = Color.Black;

            _editor.Styles[Style.Asm.CpuInstruction].ForeColor = Color.FromArgb(0, 0, 255);
            _editor.Styles[Style.Asm.MathInstruction].ForeColor = Color.FromArgb(0, 0, 255);

            _editor.Styles[Style.Asm.Register].ForeColor    = Color.FromArgb(43, 145, 175);
            _editor.Styles[Style.Asm.Directive].ForeColor   = Color.FromArgb(128, 0, 0);
            _editor.Styles[Style.Asm.Identifier].ForeColor  = Color.FromArgb(0, 0, 128);
            _editor.Styles[Style.Asm.Identifier].Bold       = true;

            // Make '_' '.' '@' '$' part of words for labels/symbols
            _editor.WordChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.$@";

            // Keyword sets for ASM lexer:
            // 0: instructions, 1: registers, 2: directives (common across MASM/NASM/GAS where possible)
            _editor.SetKeywords(0,
                "aaa aad aam aas adc add and arpl bsf bsr bswap bt btc btr bts call cbw cdq clc cld cli clts cmc "
              + "cmp cmps cmpsb cmpsd cmpsw cmpxchg cmpxchg8b cpuid cqo cwd cwde daa das dec div enter hlt idiv "
              + "imul in inc int into invd invlpg iret ja jae jb jbe jc jcxz je jecxz jg jge jl jle jmp jna jnae "
              + "jnb jnbe jnc jne jng jnge jnl jnle jno jnp jns jnz jo jp jpe jpo js jz lahf lar lea leave lgdt "
              + "lidt lldt lmsw lock lods lodsb lodsd lodsw mov movs movsb movsd movsw movsx movzx mul neg nop not or out pop popa popad popf popfd push "
              + "pusha pushad pushf pushfd rcl rcr ret retn retf rol ror sahf sal sar sbb scas scasb scasd scasw "
              + "shl shld shr shrd stc std sti stos stosb stosd stosw sub test xadd xchg xlat xor callq movq "
              + "pushq popq syscall sysret");

            _editor.SetKeywords(1,
                "al ah ax eax rax bl bh bx ebx rbx cl ch cx ecx rcx dl dh dx edx rdx "
              + "si esi rsi di edi rdi sp esp rsp bp ebp rbp "
              + "r8 r8d r8w r8b r9 r9d r9w r9b r10 r10d r10w r10b r11 r11d r11w r11b "
              + "r12 r12d r12w r12b r13 r13d r13w r13b r14 r14d r14w r14b r15 r15d r15w r15b "
              + "cs ds es fs gs ss cr0 cr2 cr3 cr4 dr0 dr1 dr2 dr3 dr6 dr7 xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 "
              + "xmm8 xmm9 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 ymm0 ymm1 ymm2 ymm3 ymm4 ymm5 ymm6 ymm7 "
              + "ymm8 ymm9 ymm10 ymm11 ymm12 ymm13 ymm14 ymm15 zmm0 zmm1 zmm2 zmm3 zmm4 zmm5 zmm6 zmm7 "
              + "zmm8 zmm9 zmm10 zmm11 zmm12 zmm13 zmm14 zmm15 rip eip ip");

            _editor.SetKeywords(2,
                "db dw dd dq dt do dy dz resb resw resd resq rest reso resy resz "
              + "byte word dword qword tbyte ptr align assume extrn extern global public common section segment "
              + "ends endp proc end include incbin equ define macro endm org use16 use32 use64 model flat stack data code");

            // Optionally: set more keyword sets (e.g., 3/4 for math or CPU-specific)
        }

        private void ConfigureMakefileStyling()
        {
            _editor.Lexer = Lexer.Properties;

            // Reset and set defaults
            _editor.StyleResetDefault();
            _editor.Styles[Style.Default].Font = "Consolas";
            _editor.Styles[Style.Default].Size = 10;
            _editor.Styles[Style.Default].BackColor = Color.White;
            _editor.Styles[Style.Default].ForeColor = Color.Black;
            _editor.StyleClearAll();

            // Scintilla Makefile lexer style indices (SCE_MAKE_*):
            // 0=Default, 1=Comment, 2=Preprocessor, 3=Identifier, 4=Operator, 5=Target, 9=IdEol
            _editor.Styles[1].ForeColor = Color.FromArgb(0, 128, 0);        // Comment (# ...)
            _editor.Styles[2].ForeColor = Color.FromArgb(128, 0, 0);        // Preprocessor (include, ifeq, etc.)
            _editor.Styles[4].ForeColor = Color.Black;                      // Operator (:, =, $, (), {})
            _editor.Styles[3].ForeColor = Color.Black;                      // Identifier / variable names
            _editor.Styles[5].ForeColor = Color.FromArgb(0, 0, 128);        // Target names
            _editor.Styles[5].Bold = true;

            // Tabs matter in recipes; prefer inserting real tabs
            _editor.UseTabs = true;
        }

        private void ConfigurePowerShellStyling()
        {
            _editor.Lexer = Lexer.PowerShell;

            _editor.StyleResetDefault();
            _editor.Styles[Style.Default].Font = "Consolas";
            _editor.Styles[Style.Default].Size = 10;
            _editor.Styles[Style.Default].BackColor = Color.White;
            _editor.Styles[Style.Default].ForeColor = Color.Black;
            _editor.StyleClearAll();

            // Basic keyword sets for PowerShell (set 0)
            _editor.SetKeywords(0,
                "function filter workflow configuration param begin process end if else elseif switch for foreach while do until break continue return throw try catch finally trap data in using class enum importmodule usingmodule parallel sequence");
        }
    }
}
