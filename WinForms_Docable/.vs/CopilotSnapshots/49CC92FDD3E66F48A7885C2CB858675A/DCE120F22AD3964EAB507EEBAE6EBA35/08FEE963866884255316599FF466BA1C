using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Threading.Tasks;
using System.Windows.Forms;
using WeifenLuo.WinFormsUI.Docking;
using System.Windows.Forms.Integration;
using ICSharpCode.AvalonEdit;
using ICSharpCode.AvalonEdit.Highlighting;
using System.Windows.Media;
using System.Reflection;
using System.Xml;
using ICSharpCode.AvalonEdit.Highlighting.Xshd;
using System.Diagnostics;
using System.Linq;
using ICSharpCode.AvalonEdit.Editing;

namespace WinForms_Docable
{
    public class CodeEditorPanel : DockContent, IThemedContent
    {
        public string FilePath { get; }

        private readonly ElementHost _host;
        private readonly TextEditor _avalon;
        private static bool _customHighlightingRegistered;

        public CodeEditorPanel(string filePath)
        {
            FilePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
            Text = Path.GetFileName(FilePath);

            RegisterCustomHighlightings();

            _host = new ElementHost { Dock = DockStyle.Fill };
            _avalon = new TextEditor
            {
                ShowLineNumbers = true,
                FontFamily = new System.Windows.Media.FontFamily("Consolas"),
                FontSize = 13,
                HorizontalScrollBarVisibility = System.Windows.Controls.ScrollBarVisibility.Auto,
                VerticalScrollBarVisibility = System.Windows.Controls.ScrollBarVisibility.Auto
            };
            _avalon.Options.ConvertTabsToSpaces = true;
            _avalon.Options.IndentationSize = 4;
            _avalon.Options.EnableHyperlinks = false;
            _avalon.Options.EnableEmailHyperlinks = false;
            _avalon.Options.HighlightCurrentLine = true;

            _host.Child = _avalon;
            Controls.Add(_host);

            if (File.Exists(FilePath))
            {
                _avalon.Text = File.ReadAllText(FilePath);
            }

            ApplySyntaxHighlighting();

            _avalon.TextChanged += (s, e) =>
            {
                if (!Text.EndsWith("*", StringComparison.Ordinal))
                    Text += "*";
            };

            this.FormClosed += (s, e) => { _host.Dispose(); };
        }

        private static void RegisterCustomHighlightings()
        {
            if (_customHighlightingRegistered) return;
            _customHighlightingRegistered = true;

            IHighlightingDefinition LoadFromResource(string resourceName)
            {
                var asm = Assembly.GetExecutingAssembly();
                using var s = asm.GetManifestResourceStream(resourceName);
                if (s == null)
                    throw new InvalidOperationException($"Missing highlighting resource: {resourceName}");
                using var reader = XmlReader.Create(s, new XmlReaderSettings { DtdProcessing = DtdProcessing.Prohibit, XmlResolver = null });
                var xshd = HighlightingLoader.LoadXshd(reader);
                return HighlightingLoader.Load(xshd, HighlightingManager.Instance);
            }

            var makefile = LoadFromResource("WinForms_Docable.Highlighting.Makefile.xshd");
            HighlightingManager.Instance.RegisterHighlighting("Makefile", new[] { ".mak", ".make", ".mk" }, makefile);

            var gas = LoadFromResource("WinForms_Docable.Highlighting.GAS.xshd");
            HighlightingManager.Instance.RegisterHighlighting("GAS", new[] { ".s", ".S", ".asm" }, gas);
        }

        private void ApplySyntaxHighlighting()
        {
            var ext = Path.GetExtension(FilePath);
            var fileName = Path.GetFileName(FilePath);
            IHighlightingDefinition? def = null;

            if (!string.IsNullOrEmpty(ext))
                def = HighlightingManager.Instance.GetDefinitionByExtension(ext);

            if (def == null && (fileName.Equals("Makefile", StringComparison.OrdinalIgnoreCase) ||
                                fileName.Equals("GNUmakefile", StringComparison.OrdinalIgnoreCase)))
            {
                def = HighlightingManager.Instance.GetDefinition("Makefile");
            }

            if (def == null && ext.Equals(".cs", StringComparison.OrdinalIgnoreCase))
                def = HighlightingManager.Instance.GetDefinition("C#");

            _avalon.SyntaxHighlighting = def;
        }

        public void FormatDocument()
        {
            var text = _avalon.Text;
            var lines = text.Replace("\r\n", "\n").Split('\n');
            var sb = new StringBuilder(text.Length + 256);
            int indent = 0;

            foreach (var raw in lines)
            {
                var trimmed = raw.Trim();

                if (trimmed.Length == 0)
                {
                    sb.AppendLine();
                    continue;
                }

                if (trimmed.StartsWith("}", StringComparison.Ordinal))
                    indent = Math.Max(0, indent - 1);

                sb.Append(new string(' ', indent * _avalon.Options.IndentationSize));
                sb.AppendLine(trimmed);

                if (trimmed.EndsWith("{", StringComparison.Ordinal))
                    indent++;
            }

            _avalon.Text = sb.ToString();
        }

        public void SaveToFile()
        {
            File.WriteAllText(FilePath, _avalon.Text);
            Text = Path.GetFileName(FilePath);
        }

        public void ApplyTheme(bool darkMode)
        {
            _host.BackColor = darkMode ? System.Drawing.Color.FromArgb(30, 30, 30) : System.Drawing.Color.White;

            var bg = darkMode ? Colors.Black : Colors.White;
            var fg = darkMode ? Colors.White : Colors.Black;

            _avalon.Background = new SolidColorBrush(bg);
            _avalon.Foreground = new SolidColorBrush(fg);

            _avalon.TextArea.Background = _avalon.Background;
            _avalon.TextArea.Foreground = _avalon.Foreground;

            _avalon.TextArea.Caret.CaretBrush = new SolidColorBrush(darkMode ? Colors.White : Colors.Black);
            _avalon.TextArea.SelectionBrush = new SolidColorBrush(darkMode
                ? System.Windows.Media.Color.FromRgb(62, 94, 138)
                : System.Windows.Media.Color.FromRgb(173, 214, 255));
            _avalon.TextArea.TextView.CurrentLineBackground = new SolidColorBrush(darkMode
                ? System.Windows.Media.Color.FromRgb(45, 45, 48)
                : System.Windows.Media.Color.FromRgb(232, 242, 254));
            _avalon.TextArea.TextView.CurrentLineBorder = null;

            _avalon.LineNumbersForeground = new SolidColorBrush(darkMode
                ? System.Windows.Media.Color.FromRgb(190, 190, 190)
                : System.Windows.Media.Colors.Gray);

            TryApplySyntaxTheme(darkMode);
        }

        private void TryApplySyntaxTheme(bool darkMode)
        {
            var themeFile = darkMode ? @"Highlighting\DarkTheme.xshd" : @"Highlighting\LightTheme.xshd";
            var path = System.IO.Path.Combine(AppContext.BaseDirectory, themeFile);
            if (!File.Exists(path)) return;

            using var s = File.OpenRead(path);
            using var reader = new XmlTextReader(s);
            var xshd = HighlightingLoader.LoadXshd(reader);
            var def = HighlightingLoader.Load(xshd, HighlightingManager.Instance);
            _avalon.SyntaxHighlighting = def;
        }
    }

    public class PowerShellPanel : DockContent, IThemedContent
    {
        private readonly RichTextBox _console;
        private readonly PwshProcessHost _pwsh;

        private readonly List<string> _history = new();
        private int _historyIndex = -1;

        private int _inputStart;
        private string? _pendingWorkingDir;

        public PowerShellPanel()
        {
            Text = "PowerShell";
            DockAreas = DockAreas.Document | DockAreas.DockBottom | DockAreas.Float;

            _console = new RichTextBox
            {
                Dock = DockStyle.Fill,
                Font = new Font("Consolas", 10f),
                ReadOnly = false,
                Multiline = true,
                WordWrap = false,
                HideSelection = false
            };

            Controls.Add(_console);

            _pwsh = new PwshProcessHost();
            _pwsh.Output += OnPwshOutput;
            _pwsh.Error += OnPwshOutput;

            AppendLine("pwsh process session started.");
            _inputStart = _console.TextLength;

            _console.KeyDown += OnConsoleKeyDown;
            _console.MouseDown += OnConsoleMouseDown;
            _console.SelectionChanged += OnConsoleSelectionChanged;
        }

        public void ApplyTheme(bool darkMode)
        {
            var bg = darkMode ? Color.FromArgb(30, 30, 30) : Color.White;
            var fg = darkMode ? Color.Gainsboro : Color.Black;

            BackColor = bg;
            ForeColor = fg;

            _console.BackColor = bg;
            _console.ForeColor = fg;
            _console.BorderStyle = BorderStyle.None;
        }

        private void OnPwshOutput(string text)
        {
            if (IsDisposed) return;
            if (InvokeRequired) { BeginInvoke(new Action<string>(OnPwshOutput), text); return; }

            Append(text);
            _inputStart = _console.TextLength;
            _console.SelectionStart = _console.TextLength;
            _console.ScrollToCaret();

            if (!string.IsNullOrEmpty(_pendingWorkingDir))
            {
                var dir = _pendingWorkingDir;
                _pendingWorkingDir = null;
                ApplyWorkingDirectory(dir!, refreshPrompt: false);
            }
        }

        private void Append(string text)
        {
            if (IsDisposed) return;
            if (InvokeRequired) { BeginInvoke(new Action<string>(Append), text); return; }
            _console.AppendText(text);
            _console.SelectionStart = _console.TextLength;
            _console.ScrollToCaret();
        }

        private void AppendLine(string text) => Append(text + Environment.NewLine);

        private void ClearConsole()
        {
            if (IsDisposed) return;
            if (InvokeRequired) { BeginInvoke(new Action(ClearConsole)); return; }
            _console.Clear();
            _console.SelectionStart = 0;
            _inputStart = 0;
        }

        private string GetInputText()
        {
            var start = _inputStart;
            var len = Math.Max(0, _console.TextLength - start);
            return len == 0 ? string.Empty : _console.Text.Substring(start, len);
        }

        private void ReplaceInput(string text)
        {
            _console.SelectionStart = _inputStart;
            _console.SelectionLength = _console.TextLength - _inputStart;
            _console.SelectedText = text ?? string.Empty;
            _console.SelectionStart = _console.TextLength;
            _console.ScrollToCaret();
        }

        private void OnConsoleMouseDown(object? sender, MouseEventArgs e)
        {
            if (_console.SelectionStart < _inputStart)
            {
                _console.SelectionStart = _console.TextLength;
                _console.SelectionLength = 0;
            }
        }

        private void OnConsoleSelectionChanged(object? sender, EventArgs e)
        {
            if (_console.SelectionStart < _inputStart)
            {
                _console.SelectionStart = _console.TextLength;
                _console.SelectionLength = 0;
            }
        }

        private void OnConsoleKeyDown(object? sender, KeyEventArgs e)
        {
            if (_console.SelectionStart < _inputStart)
            {
                _console.SelectionStart = _console.TextLength;
                _console.SelectionLength = 0;
            }

            if (e.KeyCode == Keys.Enter)
            {
                e.SuppressKeyPress = true;
                var cmd = GetInputText();

                if (!string.IsNullOrWhiteSpace(cmd))
                {
                    _history.Add(cmd);
                    _historyIndex = _history.Count;
                }

                AppendLine("");
                _pwsh.SendLine(cmd);
                _inputStart = _console.TextLength;
                return;
            }

            if (e.KeyCode == Keys.Up)
            {
                e.SuppressKeyPress = true;
                if (_history.Count == 0) return;
                _historyIndex = Math.Max(0, _historyIndex - 1);
                ReplaceInput(_history[_historyIndex]);
                return;
            }
            if (e.KeyCode == Keys.Down)
            {
                e.SuppressKeyPress = true;
                if (_history.Count == 0) return;
                _historyIndex = Math.Min(_history.Count, _historyIndex + 1);
                ReplaceInput(_historyIndex == _history.Count ? string.Empty : _history[_historyIndex]);
                return;
            }

            if (e.KeyCode == Keys.Home)
            {
                e.SuppressKeyPress = true;
                _console.SelectionStart = _inputStart;
                _console.SelectionLength = 0;
                return;
            }
            if (e.KeyCode == Keys.Left)
            {
                if (_console.SelectionStart <= _inputStart)
                {
                    e.SuppressKeyPress = true;
                    _console.SelectionStart = _inputStart;
                    _console.SelectionLength = 0;
                    return;
                }
            }
            if (e.KeyCode == Keys.Back)
            {
                if (_console.SelectionStart <= _inputStart)
                {
                    e.SuppressKeyPress = true;
                    return;
                }
            }
            if (e.KeyCode == Keys.Delete)
            {
                var selStart = Math.Min(_console.SelectionStart, _console.SelectionStart + _console.SelectionLength);
                if (selStart < _inputStart)
                {
                    e.SuppressKeyPress = true;
                    return;
                }
            }

            if (e.Control && e.KeyCode == Keys.C)
            {
                e.SuppressKeyPress = true;
                AppendLine("^C (cancel not available for external pwsh host)");
                _inputStart = _console.TextLength;
                return;
            }

            if (e.Control && e.KeyCode == Keys.V)
            {
                e.SuppressKeyPress = true;
                var text = Clipboard.GetText();
                if (string.IsNullOrEmpty(text)) return;
                _console.SelectedText = text;
            }
        }

        public void SetWorkingDirectory(string path)
        {
            if (string.IsNullOrWhiteSpace(path) || !Directory.Exists(path)) return;

            if (!_pwsh.IsRunning)
            {
                _pendingWorkingDir = path;
                return;
            }

            ApplyWorkingDirectory(path, refreshPrompt: false);
        }

        private static string QuotePwsh(string path) => "'" + path.Replace("'", "''") + "'";

        private void ApplyWorkingDirectory(string path, bool refreshPrompt)
        {
            try
            {
                _pwsh.SendLine($"Set-Location -LiteralPath {QuotePwsh(path)}");
                if (refreshPrompt && string.IsNullOrEmpty(GetInputText()))
                    ReplaceInput(string.Empty);
            }
            catch (Exception ex)
            {
                AppendLine($"Set-Location error: {ex.Message}");
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _pwsh?.Dispose();

                _console.KeyDown -= OnConsoleKeyDown;
                _console.MouseDown -= OnConsoleMouseDown;
                _console.SelectionChanged -= OnConsoleSelectionChanged;
            }
            base.Dispose(disposing);
        }

        protected override void OnHandleCreated(EventArgs e)
        {
            base.OnHandleCreated(e);
            if (!_pwsh.IsRunning)
                _pwsh.Start("-NoLogo -NoExit");
        }
    }
}